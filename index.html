<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />

	<style type="text/css">
		div.bar {
			--volume: 0%;
			background-color: gray;
		}
		div.bar::before {
			content: '';
			position: absolute;
			top: 0;
			bottom: 0;
			left: 0;
			width: var(--volume);
			background-color: green;
			transition: width 100ms linear;
		}
	</style>
</head>

<script type="importmap">
	{
		"imports": {
		   "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
		   "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
		   "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js",
		   "@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3.4.2/lib/three-vrm-animation.module.js"
		}
	}
</script>


<body bgcolor="#ffffee">

	<!-- bar -->
	<div class="bar" id="volume-bar" style="position:absolute;top:50px;left:250px;width:300px;height:10px;" >
	</div>

	<!--  toggle   -->
	<div id="target_control_panel"   style="z-index:30;position:absolute;top:5px;left:5px;" >
	</div>

	<!-- start stop button -->
	<div id="button_control"  style="z-index:20;position:absolute;top:50px;left:50px;" >
		<button id="start" >Start</button> only formation (use mic)<br />
		<button id="stop"  >Stop </button><br />
		<br />
		Upload sound file<span id="sound">Sound</span>
		<input id="upload_sound_file" type="file" />
		<br />
		<button id="sound_start" >Sound file start</button>
		<button id="sound_stop" >Sound file stop</button>
	</div>


	<!-- control_panel -->
	<div id="control_panel" style="z-index:20;position:absolute;top:100px;left:700px;background-color:#ddd" >
		<br />
		<input type="checkbox" id="camera_movement" >Use camera movement 数値設定したカメラの動きを使う<br />

		<br />
		Speed of Animation アニメーションのスピード<br />
		<input type="range" id="time_scale"  min="0" max="3" step="0.001" value="1.0" /><span id="time_scale_label">0</span><br />
		<br />

		VRMキャラクタの入れ替え(1体のみ入替可)
		<input id="read_file_vrm0" type="file" /><br />

		<br />
		Lip-Sync 音量に合わせて口を
		<input type="radio" id="mouth_sw" name="mouth_sw" value="1">Use lip-Sync/
		<input type="radio" id="mouth_sw" name="mouth_sw" value="0">Not use lip-Sync
		<br />
		<!--  開くが１で，開かないが０になっているので注意   -->

		<br />
		level0:--<br />
		level1:<input type="text" id="level1" value="0.2"><br />
		level2:<input type="text" id="level2" value="0.3"><br />
		level3:<input type="text" id="level3" value="0.35"><br />

		<textarea rows="15" cols="60"></textarea>
	</div>

<script>


	let renderer, scene, camera;

	let control_panel_flg = 1;

	let vrm_character_array  =  new Array();
	let character_load_flg   =  new Array();

	let vrma_counter = 0;
	let vrma_array      = new Array();
	let vrma_array_name = new Array();

	let next_currentMixer = new Array();

	let sound_file_data = null;
	let audio_blob_url  = null;

</script>


<script type="module">

	import * as THREE from 'three';
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
	import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
	import { createVRMAnimationClip, VRMAnimationLoaderPlugin, VRMLookAtQuaternionProxy } from '@pixiv/three-vrm-animation';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

	let gltf_loader = new GLTFLoader();
	gltf_loader.crossOrigin = 'anonymous';

	gltf_loader.register((parser) => {
		return new VRMLoaderPlugin(parser);
	});

	gltf_loader.register((parser) => {
		return new VRMAnimationLoaderPlugin(parser);
	});

	let gv = THREE.VRM;
	let clock = new THREE.Clock();


function upload_sound_file_api(number,input){

	let reader = new FileReader();
	reader.addEventListener('load', function() {
		let blob = new Blob( [input], { type: "application/octet-stream" } );
		audio_blob_url = URL.createObjectURL(blob);

		// input.name < file name
		// url < sound date

		// using audio tag

		sound_file_data   =   document.createElement("audio");
		sound_file_data.src  =  audio_blob_url;
		sound_file_data.id = "sound_file_data";
		document.body.appendChild(sound_file_data);

console.log(audio_blob_url);
console.log(sound_file_data);

	}, true)

	reader.readAsDataURL(input);

}






function init(){

	renderer = new THREE.WebGLRenderer({ alpha: true });

////	renderer.setSize( window.innerWidth/2, window.innerHeight );
////	renderer.setPixelRatio( window.devicePixelRatio );


	renderer.setSize( window.innerWidth/4, window.innerHeight );  //なぜか４で割ると真正面になる
	renderer.setPixelRatio( 10 );

	renderer.setClearColor(0x000000, 0); // transparent


	let option_str = "position:absolute;z-index:0;top:0px;left:0px;width:"+window.innerWidth+"px;height:"+window.innerHeight+"px;";
//top and left are changed based on basic_settings.js
//console.log(option_str);


	renderer.domElement.setAttribute("style", option_str);
	renderer.domElement.id = "character_window";

//console.log("renderer.domElement",renderer.domElement );

	document.body.appendChild( renderer.domElement );



////	let camera = new THREE.PerspectiveCamera( 30.0, window.innerWidth / window.innerHeight, 0.1, 20.0 );
////	let camera = new THREE.PerspectiveCamera(40.0,   (window.innerWidth/2) / window.innerHeight    , 0.1,  200.0 );



	camera = new THREE.PerspectiveCamera(3.0,   (window.innerWidth) / (window.innerHeight+100)    ,1,  800.0 );
// はじめのパラメータがFOV
// 遠近感をそれほど強調したくない場合は視野角を小さくする

	//さいごのパラメータはたとえば２００ならば
	// カメラの位置からZ軸（手前から奥）200以降は描画しないことにする，という意味


//	camera.position.set( camera_position[0],  camera_position[1], camera_position[2] );
//	camera.rotation.set( camera_rotation[0],  camera_rotation[1], camera_rotation[2] );

	camera.position.set( camera_work[0][0],  camera_work[0][1], camera_work[0][2] );
	camera.rotation.set( camera_work[0][3],  camera_work[0][4], camera_work[0][5] );

////camera.lookAt(new THREE.Vector3(0, 0, 0));

	// controls
	const controls = new OrbitControls( camera, renderer.domElement );
	controls.screenSpacePanning = true;
	controls.target.set( 0.0, 0.0, 0.0 );
	controls.update();

controls.addEventListener('change', () => {
	console.log('camera moved');
	console.log(
		Math.round(camera.position.x*10)/10+","+
		Math.round(camera.position.y*10)/10+","+
		Math.round(camera.position.z*10)/10+","+
		Math.round(camera.rotation.x*10)/10+","+
		Math.round(camera.rotation.y*10)/10+","+
		Math.round(camera.rotation.z*10)/10
	);

		renderer.render(scene, camera);
});

	// scene
	scene = new THREE.Scene();

	// light
	let light = new THREE.DirectionalLight( 0xffffff, Math.PI );
	light.position.set( 1.0, 1.0, 1.0 ).normalize();
	scene.add(light);

	// helpers
	let gridHelper = new THREE.GridHelper( 30,30 );
	scene.add(gridHelper);
	let axesHelper = new THREE.AxesHelper( 10 );
	scene.add(axesHelper);

	// load VRM character files
	for( let i=0;i<vrm_files.length;i++){
		static_vrm_load(i, vrm_files[i]);
	}

	for(let i=0;i<vrm_files.length;i++){
		vrma_array[i] = [];
		vrma_array_name[i] = [];
	}

	for( let i=0;i<vrm_files.length;i++){
		static_load2(i, 0, song_pattern[i][0] );
		static_load2(i, 1, song_pattern[i][1] );
		static_load2(i, 2, song_pattern[i][2] );
		static_load2(i, 3, song_pattern[i][3] );
	}

}
// end of init



function read_vrm_file_api(number,input){

	let reader = new FileReader();

	reader.addEventListener('load', function() {

		// delete character
		let old_vrm   =  vrm_character_array[number];
		if(typeof old_vrm === "undefined"){
		}else{
			scene.remove(old_vrm.scene);
		}

		let vrm_file_content = reader.result;

		character_load_flg[number] = -1;
		vrm_model_load(number, vrm_file_content, 0, 3, 0 );

		vrm_anime_check_change(character_change_sub , number );

	}, true)
	reader.readAsDataURL(input);
}












async function vrm_model_load(character_id, vrm_file_name, x,y,z){

	let my_loader = gltf_loader;

	my_loader.crossOrigin = 'anonymous';

	my_loader.load(  vrm_file_name,  ( gltf ) => {

				let my_vrm = gltf.userData.vrm;

console.log("gltf.userData",gltf.userData);

				character_load_flg[character_id] = 0;
				vrm_character_array[character_id] = my_vrm;

				const lookAtQuatProxy = new VRMLookAtQuaternionProxy( my_vrm.lookAt );
				lookAtQuatProxy.name = 'lookAtQuaternionProxy';
				my_vrm.scene.add( lookAtQuatProxy );


				vrm_character_array[character_id] = my_vrm;

				initCharacter( my_vrm );

				scene.add( my_vrm.scene );


		},
		( progress ) => {
			let percent = ( progress.loaded / progress.total ) *100 ;
			console.log("Loading model..."+vrm_file_name+","+percent+"%" );
		}
	);

}

function body_rotation(bone_name, character_id, x,y,z){
	let this_vrm = vrm_character_array[character_id];
	this_vrm.humanoid.getRawBoneNode(bone_name).rotation.x = x;
	this_vrm.humanoid.getRawBoneNode(bone_name).rotation.y = y;
	this_vrm.humanoid.getRawBoneNode(bone_name).rotation.z = z;
	renderer.render(scene, camera);
}

function initCharacter( vrm ) {
	vrm.humanoid.getRawBoneNode( 'leftUpperArm' ).rotation.z   =   Math.PI /180 * 72;
	vrm.humanoid.getRawBoneNode( 'rightUpperArm' ).rotation.z  =  -Math.PI /180 * 72;
	vrm.humanoid.getRawBoneNode( 'leftLowerArm' ).rotation.z   =   Math.PI /180 * 15;
	vrm.humanoid.getRawBoneNode( 'rightLowerArm' ).rotation.z  =  -Math.PI /180 * 15;
	renderer.render(scene, camera);
}

function vrm_rot_Hips(character_id, x,y,z){
	body_rotation('hips', character_id, x,y,z);
}


function vrm_anime_check_change(callback,number){
	if(character_load_flg[number] == -1){
		setTimeout(vrm_anime_check_change, 200, callback,number);
	}else{
		callback(number);	
	}
}


function character_change_sub( number ){
	let this_vrm   =  vrm_character_array[number];
	vrm_rot_Hips( number,  
		characters_rotation[number][0],
		characters_rotation[number][1],
		characters_rotation[number][2]
	);	
	this_vrm.humanoid.getRawBoneNode('hips').position.set(
//		characters_position[number][0],
//		characters_position[number][1],
//		characters_position[number][2]
		formation[0][number][0],
		formation[0][number][1],
		formation[0][number][2]
	);
	renderer.render(scene, camera);
}


	let exec_vrma = null;


function open_mouth(level){

	if(mouth_sw_flg == 0){
		return;
	}

	for(let i=0;i<vrm_files.length;i++){
		vrm_character_array[i].expressionManager.setValue(vrm_character_array[i].expressionManager.mouthExpressionNames[0], level )  
	}

	renderer.render(scene, camera);
}

exec_vrma = (level)=>{

	let my_level  =  level / 127;

	let level1 = Number(document.getElementById("level1").value)
	let level2 = Number(document.getElementById("level2").value)
	let level3 = Number(document.getElementById("level3").value)

console.log("my_level=",my_level);

	if( my_level  <  level1){
		next_vrma(0);

	}else if( my_level  <  level2){
		next_vrma(1);
		open_mouth(0.3);
		setTimeout(open_mouth,1500, 0);


	}else if( my_level  <  level3){
		next_vrma(2);
		open_mouth(0.4);
		setTimeout(open_mouth,1500, 0);


	}else{
		next_vrma(3);
		open_mouth(0.6);
		setTimeout(open_mouth,1500, 0);


	}

};





function static_vrm_load(number, url){
	character_load_flg[number] = -1;
    vrm_model_load(number,  url,     0,    0, 0  );   // キャラクタが表示されるときの初期位置
	vrm_anime_check_change(character_change_sub , number );
}




function static_load2(character_id, number, url) {

	gltf_loader.load(url, ( gltf ) => {

		vrma_array[character_id][number]  =  gltf;
		vrma_array_name[character_id][number]  =  url;

console.log("character_id,number",character_id,number);

		},
		( progress ) => console.log( 'Loading vrma2:', 100.0 * ( progress.loaded / progress.total ), '%' ),
		( error ) => console.error( error )
	);
}







	clock.start();
	let animation_flg = 0;
	animate();


function next_vrma( number ) {


	for(let i=0;i<vrm_files.length;i++){

		let next_vrmAnimations = vrma_array[i][number].userData.vrmAnimations;
		let next_currentVrmAnimation = new Array();

		next_currentVrmAnimation[i] = next_vrmAnimations[ 0 ] ?? null;

		next_currentMixer[i] = new THREE.AnimationMixer( vrm_character_array[i].scene );
		let next_clip = createVRMAnimationClip( next_currentVrmAnimation[i], vrm_character_array[i] );

		next_currentMixer[i].clipAction( next_clip ).play();
///		next_currentMixer.timeScale = params.timeScale;
		next_currentMixer[i].timeScale = document.getElementById('time_scale').value;

	}

	animation_flg = 1; //ここでONにする


}



function animate() {

	requestAnimationFrame( animate );

	if(animation_flg == 0){
	}else{

		let deltaTime = clock.getDelta();

		for(let i=0;i<vrm_files.length;i++){
			if ( next_currentMixer[i] ) {
				next_currentMixer[i].update( deltaTime );
			}

			if ( vrm_character_array[i] ) {
				vrm_character_array[i].update( deltaTime );
			}
		}

		for(let i=0;i<vrm_files.length;i++){
			vrm_rot_Hips( i,  
				characters_rotation[i][0],
				characters_rotation[i][1],
				characters_rotation[i][2]
			);	

			vrm_character_array[i].humanoid.getRawBoneNode('hips').position.set(
//				characters_position[i][0],
//				characters_position[i][1],
//				characters_position[i][2]
				formation[0][i][0],
				formation[0][i][1],
				formation[0][i][2]
			);
		}

		renderer.render( scene, camera );
	}
}


// コントロールするパネルのトグル処理（左上）

function make_toggle() {

	let target_tag = document.getElementById("target_control_panel");

	let span_tag = document.createElement("span");
//	span_tag.style.position='absolute';
	span_tag.innerHTML = "<input type='button' value='設定表示切替' id='display_button'>";
	span_tag.style.zIndex = 24;

console.log(span_tag);

	target_tag.appendChild(span_tag);

	document.getElementById("display_button").addEventListener('click', function (){
		let control_panel_tag = document.getElementById("control_panel");

		if(control_panel_tag == null)return;

		if(control_panel_flg == 1){
			control_panel_tag.style.visibility ="hidden";
		}else if(control_panel_flg == -1){
			control_panel_tag.style.visibility ="visible";
		}
		control_panel_flg *= -1;
	});


}
// end of make_toggle









window.addEventListener('DOMContentLoaded', function() {

	const startButton  =  document.getElementById('start');
	const stopButton   =  document.getElementById('stop');


startButton.addEventListener('click', () => {
	my_audio();
	my_formation();

//	animation_flg = 1;
	volumeInterval = setInterval(volumeCallback,     volumeCallback_interval      );
});


stopButton.addEventListener('click', () => {
	animation_flg = 0;
	if(volumeInterval !== null) {
		clearInterval(volumeInterval);
		volumeInterval = null;
	}
});



document.getElementById('upload_sound_file').addEventListener('change', function(event){
	let input = document.getElementById('upload_sound_file').files[0];
	upload_sound_file_api(0,input);
}, true)


document.getElementById('time_scale').addEventListener('change', function() {
	next_currentMixer.timeScale   =   document.getElementById('time_scale').value;
	document.getElementById('time_scale_label').innerHTML  =  document.getElementById('time_scale').value;
});


	document.getElementById('read_file_vrm0').addEventListener('change', function(){
		let input = document.getElementById('read_file_vrm0').files[0];
		read_vrm_file_api(0,input);
	}, true)

	document.getElementsByName("mouth_sw").forEach(t => t.addEventListener('change', function (){
			let mouth_sw_tag = document.getElementsByName("mouth_sw");
			mouth_sw_tag.forEach(key => {
				if(key.checked){
					mouth_sw_flg = key.value;
				}
			});
		})
	);

	document.getElementById('time_scale_label').innerHTML  =  document.getElementById('time_scale').value;


	let load_script_filename = [
					"./basic_settings.js",
					"./our_character_settings.js"
				]     // 最後のカンマが無いことに注意


	let scripts = new Array();

	load_script_filename.forEach(function(element,i) {
		scripts[i] = element+"?"+(new Date()).getTime();       // cache対策でファイル名を書き換え
	});

	load_js_script_callback(scripts);
	let file_counter = 0;

	function load_js_script_callback(elems) {
		let script = new Array();
		elems.forEach(function(element,i) {
			script[i] = document.createElement('script');
			script[i].src = element;
			document.body.appendChild(script[i]);
			script[i].onload = function() {
				console.log("script loaded",load_script_filename.length, file_counter, element);
				if(file_counter >= load_script_filename.length - 1 ){
					settings();  ////// jump to setting after reading .js files
				}
				file_counter++;
			};
		});
	}

});
// end of DOMContentLoaded



function settings(){

	make_toggle();

	// reset all radio buttons
	let radio_tags = document.querySelectorAll('input[type="radio"]');
	for(let i=0; i < radio_tags.length; i++) {
		radio_tags[i].checked = false;
	}


	// input parameters based on basic_settings.js
	

	// Lip sync
	let mouth_tags = document.getElementsByName("mouth_sw");
	if(mouth_sw_flg == 1){ mouth_tags[0].checked = true;}
	if(mouth_sw_flg == 0){ mouth_tags[1].checked = true;}
	// チェックの位置が上/下 1/0と直感と入れ替わっているので注意すること

	// Level thresholds
	document.getElementById("level1").value = level1_value;
	document.getElementById("level2").value = level2_value;
	document.getElementById("level3").value = level3_value;


	// Animation speed
	document.getElementById("time_scale").value = animation_speed;
	document.getElementById('time_scale_label').innerHTML  =  document.getElementById('time_scale').value;

	init();

	setTimeout(function (){
		formation_calc();
	},2000);


	//描画位置の変更(initのあとにやること)
	document.getElementById("character_window").style.top = ""+character_top+"px";
	document.getElementById("character_window").style.left =""+character_left+"px";

console.log(document.getElementById("character_window").style);

	// Background Image
	if(background_image!=null){
		document.body.style.backgroundImage  = "url(" + background_image + ")";
		document.body.style.backgroundRepeat = "no-repeat";
		document.body.style.backgroundSize   = "cover";
	}





}
















	let volumeInterval = null;
	const volumeVisualizer = document.getElementById('volume-bar');

document.getElementById('sound_stop').addEventListener('click', () => {
	const audioElement = document.querySelector("audio");
	audioElement.stop();
});

document.getElementById('sound_start').addEventListener('click', () => {


    audioContext = new AudioContext();
    audioSource = audioContext.createMediaElementSource( sound_file_data  );//element
	//こちらはElement, Streamでない

	audioSource.connect(audioContext.destination); // このconnectが必要

    analyser = audioContext.createAnalyser();

console.log("ac,as,al",audioContext);
console.log("ac,as,al",audioSource);
console.log("ac,as,al",analyser);

    analyser.fftSize = 512;
    analyser.minDecibels = -127;
    analyser.maxDecibels = 0;
    analyser.smoothingTimeConstant = 0.4;
    audioSource.connect(analyser);
    volumes = new Uint8Array(analyser.frequencyBinCount);


	const audioElement = document.querySelector("audio");
	audioElement.play();


	my_formation();


	volumeInterval = setInterval(volumeCallback,     volumeCallback_interval      );
});







    let audioStream;
    let audioContext;
    let audioSource;

    let analyser;
    let volumes;

	let delete_a;


async function my_audio(){

     audioStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: true
      }
    });

    audioContext = new AudioContext();
    audioSource = audioContext.createMediaStreamSource(audioStream);
    analyser = audioContext.createAnalyser();

console.log("audioContext,audioSource,analyser",audioContext,audioSource,analyser);

    analyser.fftSize = 512;
    analyser.minDecibels = -127;
    analyser.maxDecibels = 0;
    analyser.smoothingTimeConstant = 0.4;
    audioSource.connect(analyser);
    volumes = new Uint8Array(analyser.frequencyBinCount);

}


let e_counter=0;

    function volumeCallback(){

      analyser.getByteFrequencyData(volumes);
      let volumeSum  =  0;

      for(const volume of volumes)
        volumeSum += volume;


      let  averageVolume = volumeSum / volumes.length;


////averageVolume *= 2;

averageVolume *= volume_times ;

//console.log("averageVolume=",averageVolume)

// 10回に１回に
//if(e_counter > 10){


if(e_counter > e_counter_setting){

//前の動作が残っていたら消すようにする？
if(delete_a != null){clearTimeout(delete_a);}

    delete_a = setTimeout(exec_vrma,0,averageVolume);
	e_counter =0;
}

e_counter++;

      // Value range: 127 = analyser.maxDecibels - analyser.minDecibels;
      volumeVisualizer.style.setProperty('--volume', (averageVolume * 100 / 127) + '%');
    };


//  } catch(e) {
//    console.error('Failed to initialize volume visualizer, simulating instead...', e);
//    // Simulation
//    //TODO remove in production!
//    let lastVolume = 50;
//    volumeCallback = () => {
//      const volume = Math.min(Math.max(Math.random() * 100, 0.8 * lastVolume), 1.2 * lastVolume);
//      lastVolume = volume;
//      volumeVisualizer.style.setProperty('--volume', volume + '%');
//    };
//  }

</script>

</body>

</html>


